#!/usr/bin/env python3

from sys import argv
from enum import Enum, unique
from subprocess import run, PIPE
import csv

def error(msg, code=1):
    print('git-b: ' + msg)
    exit(code)

def rem_end_nl(s):
    return s[:-1] if s[-1:] == '\n' else s

def cmd(*cmd_list):
    res = run(cmd_list, stdout=PIPE)
    if res.returncode != 0:
        error("\n  The command:\n      " \
              + ' '.join(cmd_list) \
              + "\n  exited with code:\n      " \
              + str(res.returncode))
        exit(res.returncode)
    retstr = res.stdout.decode('utf-8')
    return rem_end_nl(retstr)

# globals

dot_git = cmd('git', 'rev-parse', '--show-toplevel') + '/.git'

history_len = 40
history_path = dot_git + '/git-b-history'

# lexer

def integers(start=0):
    i = start - 1
    while True:
        i += 1
        yield i

@unique
class Token(Enum):
    __ints = integers(1)
    #
    ID = next(__ints)
    STR = next(__ints)
    # options
    PREV = next(__ints)
    HISTORY = next(__ints)
    BRANCH = next(__ints)
    NEW = next(__ints)
    ANNOTATE = next(__ints)
    STATUS = next(__ints)
    DELETE = next(__ints)
    FORCE_DELETE = next(__ints)
    LIST = next(__ints)
    LIST_HISTORY = next(__ints)
    SHOW_DELETED = next(__ints) # TODO: implement
    RAW_LIST = next(__ints)
    RAW_LIST_HISTORY = next(__ints)
    HELP = next(__ints)
    #
    UPDATE_IDS = next(__ints)

def option_token(arg):
    opt2tok = {('-'): Token.PREV,
               ('-i', '--history'): Token.HISTORY,
               ('-b', '--branch'): Token.BRANCH,
               ('-n', '--new'): Token.NEW,
               ('-a', '--annotate'): Token.ANNOTATE,
               ('-s', '--status'): Token.STATUS,
               ('-d', '--delete'): Token.DELETE,
               ('-D', '--force-delete'): Token.FORCE_DELETE,
               ('-l', '--list'): Token.LIST,
               ('-lh', '--list-history'): Token.LIST_HISTORY,
               ('-rl', '--raw-list'): Token.RAW_LIST,
               ('-rh', '--raw-history'): Token.RAW_LIST_HISTORY,
               ('-h', '-u', '--usage'): Token.HELP}
    for names, tok in opt2tok.items():
        if arg in names:
            return tok
    error('Bad option: ' + arg)

def token(arg):
    if arg:
        if arg[0] == '-':
            return option_token(arg)
        if arg[0] == ':':
            return Token.ID
    # it may as well be an empty string
    return Token.STR

def lex(args):
    return map(lambda arg: {'type': token(arg), 'lexem': arg}, args)

# implementation

def branches():
    retstr = cmd('git', 'for-each-ref', '--format="%(refname:short)"', 'refs/heads/')
    return list(map(lambda ln: ln.strip('"'), retstr.split('\n')))

class Branch:
    def __init__(self, dictionary):
        self.__dict__.update(dictionary)

    def cmp(self, other):
        self_recency = int(self.recency)
        other_recency = int(other.recency)
        if self_recency < other_recency:
            return -1
        elif self_recency > other_recency:
            return 1
        else:
            self_id = int(self.id)
            other_id = int(other.id)
            if self_id < other_id:
                return -1
            elif self_id > other_id:
                return 1
            else:
                raise RuntimeError(
                    'Found two identical ids on branch {} and branch {}'
                    .format(self.branch, other.branch))

    def __lt__(self, other): return self.cmp(other) < 0
    def __gt__(self, other): return self.cmp(other) > 0
    def __eq__(self, other): return self.cmp(other) == 0
    def __le__(self, other): return self.cmp(other) <= 0
    def __ge__(self, other): return self.cmp(other) >= 0
    def __ne__(self, other): return self.cmp(other) != 0

def str_integers():
    for i in integers():
        yield str(i)

def unique_id(ids):
    for id in str_integers():
        if not id in ids:
            return id

def augmented_branch_str(branch_data, this_branch):
    id = branch_data.id
    branch = branch_data.branch
    annotation = branch_data.annotation
    status = branch_data.status
    status = '[' + status + ']' if status else ''
    if not annotation and not status:
        row = ' {:<3} {}'.format(id, branch)
    else:
        row = ' {:<3} {:<20} {:<3} {} {}'.format(id, branch, id, status, annotation)
    if branch == this_branch:
        return '*' + row
    else:
        return ' ' + row

class Metadata:
    path = dot_git + '/git-b-metadata'
    csv_fields_order = ['branch', 'id', 'recency', 'annotation', 'status']

    def __init__(self):
        self.branch_list = branches()
        self.data = []
        self.branch2data = {}
        self._id2data = {}
        self.maxrecency = -1

    @property
    def id2data(self):
        if self._id2data:
            return self._id2data
        else:
            self._id2data = dict(zip(map(lambda b: b.id, self.data),
                                     self.data))
            return self._id2data

    def ini(self):
        "Initialize fields and fix possible differences"
        try:
            f = open(Metadata.path, mode='r')
        except FileNotFoundError:
            self.create_metadata().rewrite()
        else:
            self.read_metadata(f)
            f.close()
        branches_from_data = set(self.branch2data.keys())
        difference = set(self.branch_list) ^ branches_from_data
        if difference:
            self.fix_difference(difference, branches_from_data)
        return self

    def create_metadata(self):
        self.maxrecency = 0
        common = {'recency': 0, 'annotation': '', 'status': ''}
        for index, branch in enumerate(self.branch_list):
            b_data = Branch(dict(common, id=str(index), branch=branch))
            self.data.append(b_data)
            self.branch2data[branch] = b_data
        return self

    def read_metadata(self, file):
        reader = csv.DictReader(file, Metadata.csv_fields_order)
        for row in reader:
            recency = int(row['recency'])
            if recency > self.maxrecency:
                self.maxrecency = recency
            row['recency'] = recency
            b_data = Branch(row)
            self.data.append(b_data)
            self.branch2data[b_data.branch] = b_data

    def rewrite(self):
        with open(Metadata.path, mode='w') as f:
            writer = csv.DictWriter(f, Metadata.csv_fields_order)
            for b_data in self.data:
                writer.writerow(b_data.__dict__)

    def fix_difference(self, difference, branches_from_data):
        newrecency = self.maxrecency + 1
        to_delete = []
        to_add = []
        for branch in difference:
            if branch in branches_from_data:
                to_delete.append(branch)
            else:
                to_add.append(branch)
        if to_delete:
            for branch in to_delete:
                b_data = self.branch2data[branch]
                self.branch2data.pop(b_data.branch, None)
                del self.data[self.data.index(b_data)]
        if to_add:
            common = {'recency': newrecency, 'annotation': '', 'status': ''}
            ids_set = set(map(lambda d: d.id, self.data))
            for branch in to_add:
                newid = unique_id(ids_set)
                ids_set.add(newid)
                b_data = Branch(dict(common, id=newid, branch=branch))
                self.data.append(b_data)
                self.branch2data[branch] = b_data
        self.rewrite()

    def augment(self, branches_to_augment=None):
        if branches_to_augment is None:
            branches = map(lambda d: d.branch, sorted(self.data))
        else:
            branches = branches_to_augment
        this_branch = cur_branch()
        augmented_list = []
        for branch in branches:
            try:
                b_data = self.branch2data[branch]
            except KeyError:
                augmented_list.append('  {:<3} {}'.format('-', branch))
            else:
                augmented_list.append(
                    augmented_branch_str(
                        b_data, this_branch))
        return augmented_list

    def menu(self, branches_to_augment=None):
        self.ini()
        print_str_list(self.augment(branches_to_augment))
        try:
            id = prompt('> ')
            return self.id2data[id].branch
        except KeyError:
            error('Bad id: ' + id)

def kb_interrupt():
    print()
    exit(0)

def prompt(prompt_msg):
    try:
        return input(prompt_msg)
    except KeyboardInterrupt:
        print()
        exit(0)

def make_id_a_key(data):
    data_by_id = {}
    for branch in data:
        data_by_id[data[branch]['id']] = {'branch': branch,
                                          'annotation': data[branch]['annotation'],
                                          'status': data[branch]['status']}
    return data_by_id

def history_is_empty():
    error('The history is empty')

def history():
    # TODO:
    # * store exit time in history
    # * store HEAD's hash when exited
    # * hide nonexistent branches from history
    # * * option to show these branches
    try:
        f = open(history_path, mode='r')
    except FileNotFoundError:
        history_is_empty()
    else:
        history_list = list(map(lambda ln: rem_end_nl(ln), f))
        f.close()
        return history_list

def cur_branch():
    return cmd('git', 'rev-parse', '--abbrev-ref', 'HEAD')

def cut_history():
    with open(history_path, mode='r+') as f:
        lines = list(f)
        if len(lines) > history_len:
            f.truncate(0)
            f.writelines(lines[-history_len:])

def change_branch(name, minus_b=False):
    original_branch = cur_branch()
    if minus_b:
        cmd('git', 'checkout', '-b', name)
    else:
        cmd('git', 'checkout', name)
    with open(history_path, mode='a') as f:
        f.write(original_branch + '\n')
    cut_history()

def print_str_list(lst):
    print('\n'.join(lst))

def delete_branch_by_name(name, option='-d'):
    delete_report = cmd('git', 'branch', option, name)
    print(delete_report)

def to_id(tok):
    return tok['lexem'][1:]

def branch_by_id_tok(tok):
    return Metadata().ini().id2data[to_id(tok)].branch

def bad_argument(tok):
    error('Bad argument: ' + tok['lexem'])

def common_delete_branch(t, tokens, option='-d'):
    deletions = []
    def take1():
        try:
            t = next(tokens)
        except StopIteration:
            return False
        else:
            if t['type'] == Token.STR:
                del_fn = lambda: delete_branch_by_name(t['lexem'], option)
            elif t['type'] == Token.ID:
                del_fn = lambda: delete_branch_by_name(branch_by_id_tok(t), option)
            else:
                bad_argument(t)
            deletions.append(del_fn)
            return True
    if not take1():
        delete_branch_by_name(Metadata().menu(), option)
    else:
        while take1():
            pass
        for del_fn in deletions:
            del_fn()
        Metadata().ini() # update metadata

# commands

def go_to_branch_by_name(t, tokens):
    change_branch(t['lexem'])

def go_to_branch_by_id(t, tokens):
    change_branch(branch_by_id_tok(t))

def go_to_prev_branch(t, tokens):
    try:
        f = open(history_path, mode='r')
    except FileNotFoundError:
        history_is_empty()
    else:
        name = list(f)[-1][:-1]
        f.close()
        change_branch(name)

def go_to_branch_by_history(t, tokens):
    change_branch(Metadata().menu(history()))

def new_branch(t, tokens):
    # TODO: add -n B -a A syntax
    try:
        t = next(tokens)
    except StopIteration:
        change_branch(prompt('branch name> '), minus_b=True)
    else:
        if t['type'] != Token.STR:
            error('Bad branch name: ' + t['lexem'])
        change_branch(t['lexem'], minus_b=True)

def make_an_annotation(name, annotation):
    metadata = Metadata().ini()
    metadata.branch2data[name].annotation = annotation
    metadata.rewrite()
    exit(0)

def annotate(t, tokens):
    # TODO: figure out a way to make it better
    # * maybe collect all the stuff beforehand
    # * maybe abandon these not so useful cool syntax
    annotation = []
    try:
        t = next(tokens)
    except StopIteration:
        make_an_annotation(Metadata().menu(), input('annotation> '))
    else:
        annotation.append(t['lexem'])
        while True:
            try:
                t = next(tokens)
            except StopIteration:
                make_an_annotation(Metadata().menu(), ' '.join(annotation))
            else:
                if t['type'] != Token.STR:
                    break
                else:
                    annotation.append(t['lexem'])
        if t['type'] == Token.BRANCH:
            try:
                t = next(tokens)
            except StopIteration:
                error('Expected a branch name or id after ' + t['lexem'] + ' option')
            else:
                if t['type'] == Token.STR:
                    make_an_annotation(t['lexem'], ' '.join(annotation))
                elif t['type'] == Token.ID:
                    make_an_annotation(branch_by_id_tok(t),' '.join(annotation))
                else:
                    bad_argument(t)

def status(t, tokens):
    pass

def delete_branch(t, tokens):
    common_delete_branch(t, tokens, '-d')

def force_delete_branch(t, tokens):
    common_delete_branch(t, tokens, '-D')

def print_augmented_branches(t, tokens):
    print_str_list(Metadata().ini().augment())

def print_augmented_history(t, tokens):
    print_str_list(Metadata().ini().augment(history()))

def print_raw_branch_list(t, tokens):
    print_str_list(branches())

def print_raw_history(t, tokens):
    print_str_list(history())

def print_help(t, tokens):
    print('IM HELPIN U')

def composite_command(t, tokens, ini):
    pass

def git_b(args):
    if not args:
        change_branch(Metadata().menu())
        exit(0)

    tokens = lex(args)
    type2fn = {
        Token.STR: go_to_branch_by_name, # composite command
        Token.ID: go_to_branch_by_id, # composite command
        Token.PREV: go_to_prev_branch,
        Token.HISTORY: go_to_branch_by_history,
        Token.BRANCH: lambda: error('not implemented'), # composite command
        Token.NEW: new_branch, # composite command
        Token.ANNOTATE: annotate, # composite command
        Token.STATUS: status, # composite command
        Token.DELETE: delete_branch,
        Token.FORCE_DELETE: force_delete_branch,
        Token.LIST: print_augmented_branches,
        Token.LIST_HISTORY: print_augmented_history,
        Token.RAW_LIST: print_raw_branch_list,
        Token.RAW_LIST_HISTORY: print_raw_history,
        Token.HELP: print_help
    }
    try:
        t = next(tokens)
        command_fn = type2fn[t['type']]
    except KeyError:
        bad_argument(t)
    else:
        command_fn(t, tokens)

if __name__ == '__main__':
    git_b(argv[1:])
