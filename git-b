#!/usr/bin/env python3

from sys import argv
from enum import Enum, unique
from subprocess import run, PIPE
import csv

def error(msg, code=1):
    print('git-b: ' + msg)
    exit(code)

def rem_end_nl(s):
    return s[:-1] if s[-1:] == '\n' else s

def cmd(cmd_list):
    res = run(cmd_list, stdout=PIPE)
    if res.returncode != 0:
        error("The command '" + ' '.join(cmd_list) + "' exited with code " + str(res.returncode))
        exit(res.returncode)
    retstr = res.stdout.decode('utf-8')
    return rem_end_nl(retstr)

history_len = 30
dot_git = cmd(['git', 'rev-parse', '--show-toplevel']) + '/.git'
history_path = dot_git + '/git-b-history'
augmentations_path = dot_git + '/git-b-augmentations'

# parser

@unique
class Token(Enum):
    ID = 1
    STR = 2
    # options
    PREV = 3
    HISTORY = 4
    NEW = 5
    ANNOTATE = 6
    NEW_ANNOTATE = 7
    DELETE = 8
    FORCE_DELETE = 9
    LIST = 10
    LIST_HISTORY = 11
    RAW_LIST = 12
    RAW_LIST_HISTORY = 13
    HELP = 14

def option_token(arg):
    opt2tok = {('-'): Token.PREV,
               ('-i', '--history'): Token.HISTORY,
               ('-n', '--new'): Token.NEW,
               ('-a', '--annotate'): Token.NEW_ANNOTATE,
               ('-na', '--new-annotate'): Token.NEW_ANNOTATE,
               ('-d', '--delete'): Token.DELETE,
               ('-D', '--force-delete'): Token.FORCE_DELETE,
               ('-l', '--list'): Token.LIST,
               ('-lh', '--list-history'): Token.LIST_HISTORY,
               ('-rl', '--raw-list'): Token.RAW_LIST,
               ('-rh', '--raw-history'): Token.RAW_LIST_HISTORY,
               ('-h', '--help'): Token.HELP}
    for names, token in opt2tok.items():
        if arg in names:
            return token
    return None

def token(arg):
    if arg[0] == '-':
        return option_token(arg)
    if arg[0] == ':':
        return Token.ID
    return Token.STR

def parse(args):
    return map(lambda arg: {'type': token(arg), 'lexem': arg}, args)

# implementation

def branches():
    # git for-each-ref --format='%(refname:short)' refs/heads/
    retstr = cmd(['git', 'for-each-ref', '--format="%(refname:short)"', 'refs/heads/'])
    return list(map(lambda ln: ln.strip('"'), retstr.split('\n')))

def read_metadata():
    try:
        with open(augmentations_path, mode='r') as f:
            reader = csv.DictReader(f, ['branch', 'id', 'annotation', 'status'])
            metadata = {}
            for row in reader:
                metadata[row['branch']] = {'id': row['id'],
                                           'annotation': row['annotation'],
                                           'status': row['status']}
        return metadata
    except FileNotFoundError:
        open(augmentations_path, mode='a').close()

def branch_metadata(branch_list):
    data = read_metadata()    
    if not data:        
        return rewrite(init_data(branch_list))    
    difference = set(branch_list) ^ set(data.keys())
    if difference:
        for branch in difference:
            if branch in data.keys():
                data.pop(branch, None)                
            else:
                data[branch] = {'id': unique_id(map(lambda key: data[key]['id'], data)),
                                'annotation': '',
                                'status': ''}                
        rewrite(data)
    return make_id_a_key(data)

def augmented_str(id, branch_data, this_branch):
    branch = branch_data['branch']
    annotation = branch_data['annotation']
    status = branch_data['status']
    status = '[' + status + ']' if status else ''
    if not annotation and not status:
        row = ' {:<3} {}'.format(id, branch)
    else:
        row = ' {:<3} {:<20} {:<3} {} {}'.format(id, branch, id, status, annotation)
    if branch == this_branch:
        return '*' + row
    else:
        return ' ' + row

def init_data(branch_list):
    data = {}
    for i, branch in enumerate(branch_list):
        data[branch] = {'id': i,
                        'annotation': '',
                        'status': ''}
    return data

def integers():
    i = -1
    while true:
        i += 1
        yield i

def unique_id(ids):    
    ids_set = set(ids)
    for id in integers():
        if id in ids_set:
            return id

def rewrite(data):
    with open(augmentations_path, mode='w') as f:
        writer = csv.writer(f)
        for b, b_data in data.items():
            writer.writerow([b, b_data['id'], b_data['annotation'], b_data['status']])
    return data

def make_id_a_key(data):
    data_by_id = {}
    for branch in data:
        data_by_id[data[branch]['id']] = {'branch': branch,
                                          'annotation': data[branch]['annotation'],
                                          'status': data[branch]['status']}
    return data_by_id        

def augment(branch_list):
    data = branch_metadata(branch_list)
    this_branch = cur_branch()    
    augmented_list = []
    # ids are guaranteed to be an integer interval by unique_id
    # TODO: make it sort branches by recency
    for i in range(0, len(data)):
        augmented_list.append(augmented_str(i, data[str(i)], this_branch))
    return augmented_list, data

def kb_interrupt():
    print()
    exit(0)

def menu(augmented_list_and_data_by_id):
    augmented_list, data = augmented_list_and_data_by_id
    for line in augmented_list:
        print(line)
    try:
        id = input('> ')
    except KeyboardInterrupt:
        kb_interrupt()
    return data[id]['branch']

def history():
    with open(history_path, mode='r') as f:
        return list(map(lambda ln: rem_end_nl(ln), f))

def cur_branch():
    return cmd(['git', 'rev-parse', '--abbrev-ref', 'HEAD'])

def cut_history(history_file):
    history_file.writelines(list(history_file)[-history_len:])

def change_branch(name):
    original_branch = cur_branch()
    cmd(['git', 'checkout', name])
    with open(history_path, mode='a+') as f:
        cut_history(f)
        f.write(original_branch + '\n')

# commands

def go_to_branch_by_name(t, tokens):
    change_branch(t['lexem'])

def go_to_branch_by_id(t, tokens):
    ""

def go_to_prev_branch(t, tokens):
    with open(history_path, mode='r') as f:
        name = list(f)[-1][:-1]
    change_branch(name)

def go_to_branch_by_history(t, tokens):
    change_branch(menu(augment(history_list())))

def new_branch(t, tokens):
    # TODO: add -n B -a A syntax
    def co_new(name):
        cmd(['git', 'checkout', '-b', name])
    try:
        t = next(tokens)
        if t['type'] != Token.STR:
            error('Bad branch name: ' + t['lexem'])
        co_new(t['lexem'])
    except StopIteration:
        try:
            co_new(input('branch name> '))
        except KeyboardInterrupt:
            kb_interrupt()

def annotate(t, tokens):
    ""

def new_annotate(t, tokens):
    ""

def delete_branch(t, tokens):
    ""

def force_delete_branch(t, tokens):
    ""

def print_augmented_branch_list(t, tokens):
    print(augment(branches()))

def print_augmented_history(t, tokens):
    print(augment(history()))

def print_raw_branch_list(t, tokens):
    print('\n'.join(branches()))

def print_raw_history(t, tokens):
    print('\n'.join(history()))

def print_help(t, tokens):
    print('IM HELPIN U')

def git_b(args):
    if not args:
        change_branch(menu(augment(branches())))
        exit(0)

    tokens = parse(args)
    type2fn = {
        Token.STR: go_to_branch_by_name,
        Token.ID: go_to_branch_by_id,
        Token.PREV: go_to_prev_branch,
        Token.HISTORY: go_to_branch_by_history,
        Token.NEW: new_branch,
        Token.ANNOTATE: annotate,
        Token.NEW_ANNOTATE: new_annotate,
        Token.DELETE: delete_branch,
        Token.FORCE_DELETE: force_delete_branch,
        Token.LIST: print_augmented_branch_list,
        Token.LIST_HISTORY: print_augmented_history,
        Token.RAW_LIST: print_raw_branch_list,
        Token.RAW_LIST_HISTORY: print_raw_history,
        Token.HELP: print_help
    }
    try:
        t = next(tokens)
        type2fn[t['type']](t, tokens)
    except KeyError:
        error('Bad argument: ' + t['lexem'])

if __name__ == '__main__':
    git_b(argv[1:])
