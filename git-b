#!/usr/bin/env python3

### Commentary:

# This script is an attempt to make a universal interface for interaction
# with branches for the most common tasks.
# + History of branch switching.
# + Metadata for branches.

# Is it good? I don't know, works for me.

# NOTE: Metadata is local and lives in the project's .git dir.
# For other solutions to the branch metadata problem see
#     https://stackoverflow.com/questions/2108405/branch-descriptions-in-git

from sys import argv
from enum import Enum, unique
from subprocess import run, PIPE
import csv

## AUX

def error(msg, code=1):
    print('git-b: ' + msg)
    exit(code)

def rem_end_nl(s):
    return s[:-1] if s[-1:] == '\n' else s

def cmd(*cmd_list):
    res = run(cmd_list, stdout=PIPE)
    if res.returncode != 0:
        error("\n  The command:\n      " \
              + ' '.join(cmd_list) \
              + "\n  exited with code:\n      " \
              + str(res.returncode))
        exit(res.returncode)
    retstr = res.stdout.decode('utf-8')
    return rem_end_nl(retstr)

## LEXER

def integers(start=0):
    i = start - 1
    while True:
        i += 1
        yield i

@unique
class T(Enum):
    "Token types"

    __genint = integers(1)

    ID = next(__genint)
    STR = next(__genint)

    # options
    PREV = next(__genint)
    HISTORY = next(__genint)
    BRANCH = next(__genint)
    NEW = next(__genint)
    ANNOTATE = next(__genint)
    STATUS = next(__genint)
    DELETE = next(__genint)
    FORCE_DELETE = next(__genint)
    LIST = next(__genint)
    LIST_HISTORY = next(__genint)
    RAW_LIST = next(__genint)
    RAW_LIST_HISTORY = next(__genint)
    HELP = next(__genint)

    # TODO: implement
    SHOW_DELETED = next(__genint)
    UPDATE_IDS = next(__genint)

class Token:
    def __init__(self, type, lexem):
        self.type = type
        self.lexem = lexem

def option_token(arg):
    opt2tok = {
        ('-'): T.PREV,
        ('-i', '--history'): T.HISTORY,
        ('-b', '--branch'): T.BRANCH,
        ('-n', '--new'): T.NEW,
        ('-a', '--annotate'): T.ANNOTATE,
        ('-s', '--status'): T.STATUS,
        ('-d', '--delete'): T.DELETE,
        ('-D', '--force-delete'): T.FORCE_DELETE,
        ('-l', '--list'): T.LIST,
        ('-lh', '-li', '--list-history'): T.LIST_HISTORY,
        ('-rl', '--raw-list'): T.RAW_LIST,
        ('-rh', '--raw-history'): T.RAW_LIST_HISTORY,
        ('-h', '-u', '--usage'): T.HELP
    }
    for names, tok in opt2tok.items():
        if arg in names:
            return tok
    error('Bad option: ' + arg)

def token(arg):
    if arg:
        if arg[0] == '-':
            return option_token(arg)
        if arg[0] == ':':
            return T.ID
    # it may as well be an empty string
    return T.STR

def lex(args):
    return map(lambda arg: Token(token(arg), arg), args)

## METADATA

class Branch:
    def __init__(self, dictionary):
        self.__dict__.update(dictionary)

    def cmp(self, other):
        self_recency = int(self.recency)
        other_recency = int(other.recency)
        if self_recency < other_recency:
            return -1
        elif self_recency > other_recency:
            return 1
        else:
            self_id = int(self.id)
            other_id = int(other.id)
            if self_id < other_id:
                return -1
            elif self_id > other_id:
                return 1
            else:
                raise RuntimeError(
                    'Found two identical ids on branch {} and branch {}'
                    .format(self.branch, other.branch))

    def __lt__(self, other): return self.cmp(other) < 0
    def __gt__(self, other): return self.cmp(other) > 0
    def __eq__(self, other): return self.cmp(other) == 0
    def __le__(self, other): return self.cmp(other) <= 0
    def __ge__(self, other): return self.cmp(other) >= 0
    def __ne__(self, other): return self.cmp(other) != 0

def str_integers():
    for i in integers():
        yield str(i)

def unique_id(ids):
    for id in str_integers():
        if not id in ids:
            return id

def augmented_branch_str(branch_data, this_branch):
    id = branch_data.id
    branch = branch_data.branch
    annotation = branch_data.annotation
    status = branch_data.status
    status = '[' + status + ']' if status else ''
    if not annotation and not status:
        row = ' {:<3} {}'.format(id, branch)
    else:
        row = ' {:<3} {:<20} {:<3} {} {}'.format(id, branch, id, status, annotation)
    if branch == this_branch:
        return '*' + row
    else:
        return ' ' + row

def branches():
    retstr = cmd('git', 'for-each-ref', '--format="%(refname:short)"', 'refs/heads/')
    return list(map(lambda ln: ln.strip('"'), retstr.split('\n')))

class Metadata:
    dot_git = cmd('git', 'rev-parse', '--show-toplevel') + '/.git'

    history_len = 40
    history_path = dot_git + '/git-b-history'

    path = dot_git + '/git-b-metadata'
    csv_fields_order = ['branch', 'id', 'recency', 'annotation', 'status']

    def __init__(self):
        self._initialized = False
        self._branch_list = None
        self._rewrite_scheduled = False
        self._id2data = None
        self.data = []
        self.branch2data = {}
        self.maxrecency = -1

    @property
    def branch_list(self):
        if not self._branch_list:
            self._branch_list = branches()
        return self._branch_list

    @property
    def id2data(self):
        if not self._id2data:
            self._id2data = { b.id: b for b in self.data }
        return self._id2data

    def ini(self):
        "Initialize fields and fix possible differences"
        if self._initialized:
            return self
        try:
            f = open(Metadata.path, mode='r')
        except FileNotFoundError:
            self.create_metadata().rewrite()
        else:
            self.read_metadata(f)
            f.close()
        self.check_for_difference()
        self._initialized = True
        return self

    def update(self):
        self._branch_list = branches()
        self.ini()
        self.check_for_difference()
        return self

    def create_metadata(self):
        self.maxrecency = 0
        common = {'recency': 0, 'annotation': '', 'status': ''}
        for index, branch in enumerate(self.branch_list):
            b_data = Branch(dict(common, id=str(index), branch=branch))
            self.data.append(b_data)
            self.branch2data[branch] = b_data
        return self

    def read_metadata(self, file):
        reader = csv.DictReader(file, Metadata.csv_fields_order)
        for row in reader:
            recency = int(row['recency'])
            if recency > self.maxrecency:
                self.maxrecency = recency
            row['recency'] = recency
            b_data = Branch(row)
            self.data.append(b_data)
            self.branch2data[b_data.branch] = b_data

    def schedule_rewrite(self):
        self._rewrite_scheduled = True

    def rewrite(self):
        if self._rewrite_scheduled:
            assert self._initialized and self.data
            with open(Metadata.path, mode='w') as f:
                writer = csv.DictWriter(f, Metadata.csv_fields_order)
                for b_data in self.data:
                    writer.writerow(b_data.__dict__)

    def check_for_difference(self):
        branches_from_data = set(self.branch2data.keys())
        difference = set(self.branch_list) ^ branches_from_data
        if difference:
            self.fix_difference(difference, branches_from_data)

    def fix_difference(self, difference, branches_from_data):
        newrecency = self.maxrecency + 1
        to_delete = []
        to_add = []
        for branch in difference:
            if branch in branches_from_data:
                to_delete.append(branch)
            else:
                to_add.append(branch)
        if to_delete:
            for branch in to_delete:
                b_data = self.branch2data[branch]
                self.branch2data.pop(b_data.branch, None)
                del self.data[self.data.index(b_data)]
        if to_add:
            common = {'recency': newrecency, 'annotation': '', 'status': ''}
            ids_set = set(map(lambda d: d.id, self.data))
            for branch in to_add:
                newid = unique_id(ids_set)
                ids_set.add(newid)
                b_data = Branch(dict(common, id=newid, branch=branch))
                self.data.append(b_data)
                self.branch2data[branch] = b_data
        self.schedule_rewrite()

    def augment(self, branches_to_augment=None):
        if branches_to_augment is None:
            branches = map(lambda d: d.branch, sorted(self.data))
        else:
            branches = branches_to_augment
        this_branch = cur_branch()
        augmented_list = []
        for branch in branches:
            try:
                b_data = self.branch2data[branch]
            except KeyError:
                augmented_list.append('  {:<3} {}'.format('-', branch))
            else:
                augmented_list.append(
                    augmented_branch_str(
                        b_data, this_branch))
        return augmented_list

    def menu(self, branches_to_augment=None):
        self.ini()
        print_str_list(self.augment(branches_to_augment))
        try:
            id = prompt('> ')
            return self.id2data[id].branch
        except KeyError:
            error('Bad id: ' + id)

M = Metadata() # global metadata singleton

## IMPLEMENTATION

def kb_interrupt():
    print()
    exit(0)

def prompt(prompt_msg):
    try:
        return input(prompt_msg)
    except KeyboardInterrupt:
        print()
        exit(0)

def make_id_a_key(data):
    data_by_id = {}
    for branch in data:
        data_by_id[data[branch]['id']] = {'branch': branch,
                                          'annotation': data[branch]['annotation'],
                                          'status': data[branch]['status']}
    return data_by_id

def history_is_empty():
    error('The history is empty')

def history():
    # TODO:
    # * store exit time in history
    # * store HEAD's hash when exited
    # * hide nonexistent branches from history
    # * * option to show these branches
    try:
        f = open(M.history_path, mode='r')
    except FileNotFoundError:
        history_is_empty()
    else:
        history_list = list(map(lambda ln: rem_end_nl(ln), f))
        f.close()
        return history_list

def cur_branch():
    return cmd('git', 'rev-parse', '--abbrev-ref', 'HEAD')

def cut_history():
    with open(M.history_path, mode='r+') as f:
        lines = list(f)
        if len(lines) > M.history_len:
            f.truncate(0)
            f.writelines(lines[-M.history_len:])

def change_branch(name, minus_b=False):
    original_branch = cur_branch()
    if minus_b:
        cmd('git', 'checkout', '-b', name)
        M.ini().schedule_rewrite()
    else:
        cmd('git', 'checkout', name)
    with open(M.history_path, mode='a') as f:
        f.write(original_branch + '\n')
    cut_history()

def print_str_list(lst):
    print('\n'.join(lst))

def delete_branch_by_name(name, option='-d'):
    delete_report = cmd('git', 'branch', option, name)
    print(delete_report)

def to_id(tok):
    return tok.lexem[1:]

def branch_by_id_tok(tok):
    return M.ini().id2data[to_id(tok)].branch

def bad_argument(tok):
    error('Bad argument: ' + tok.lexem)

def common_delete_branch(t, tokens, option='-d'):
    deletions = []
    def take1():
        try:
            t = next(tokens)
        except StopIteration:
            return False
        else:
            if t.type == T.STR:
                del_fn = lambda: delete_branch_by_name(t.lexem, option)
            elif t.type == T.ID:
                del_fn = lambda: delete_branch_by_name(branch_by_id_tok(t), option)
            else:
                bad_argument(t)
            deletions.append(del_fn)
            return True
    if not take1():
        delete_branch_by_name(M.menu(), option)
    else:
        while take1():
            pass
        for del_fn in deletions:
            del_fn()
    M.update().schedule_rewrite()

## COMPOSITE COMMAND IMPLEMENTATION

def take_next_branch(tokens):
    try:
        t = next(tokens)
    except StopIteration:
        return True, None
    else:
        if t.type == T.STR:
            return t.lexem, None
        elif t.type == T.ID:
            return branch_by_id_tok(t), None
        else:
            return True, t

def take_next_new_branch(tokens):
    try:
        t = next(tokens)
    except StopIteration:
        return True, None
    else:
        if t.type == T.STR:
            return t.lexem, None
        else:
            return None, t

def take_upto_non_str(tokens):
    annotation = []
    getres = lambda: ' '.join(annotation) if annotation else True
    while True:
        try:
            t = next(tokens)
        except StopIteration:
            return getres(), None
        else:
            if t.type == T.STR or t.type == T.ID:
                annotation.append(t.lexem)
            else:
                return getres(), t

def parse_composite_command(t, tokens, info):
    typemap = {
        T.BRANCH: ('branch', take_next_branch),
        T.NEW: ('new-branch', take_next_new_branch),
        T.ANNOTATE: ('annotation', take_upto_non_str),
        T.STATUS: ('status', take_upto_non_str)
    }
    next_t = t
    while True:
        if next_t:
            t = next_t
            next_t = None
        else:
            try:
                t = next(tokens)
            except StopIteration:
                return info
        field, fn = typemap[t.type]
        value, next_t = fn(tokens)
        info[field] = value

def get(dict, field):
    try:
        return dict[field]
    except KeyError:
        return None

def destruct(info):
    return get(info, 'branch'), get(info, 'new-branch'), \
           get(info, 'annotation'), get(info, 'status')

def my_bool(arg):
    if arg == '':
        return True
    return bool(arg)

def boolify(*args):
    return tuple( my_bool(arg) for arg in args )

def annotate(branch, annotation):
    M.ini()
    M.branch2data[branch].annotation = annotation
    M.schedule_rewrite()

def add_status(branch, status):
    M.ini()
    M.branch2data[branch].status = status
    M.schedule_rewrite()

## COMMANDS

def composite_command(field, take_field):
    def fn(_, tokens):
        value, next_t = take_field(tokens)
        info = parse_composite_command(next_t, tokens, { field: value })
        branch, new_branch, annotation, status = destruct(info)

        # cut off edge cases
        if boolify(branch, new_branch) == (True, True):
            error('Mutually exclusive arguments: --branch and --new-branch')
        elif boolify(branch, annotation, status) == (True, False, False):
            change_branch(branch)
            exit(0)

        # set branch to work with
        branch_name = None
        if branch == True:
            branch_name = M.menu()
        elif branch:
            branch_name = branch
            print('branch> ', branch_name)
        elif new_branch == True:
            branch_name = M.menu()
        elif new_branch:
            branch_name = new_branch
            change_branch(branch_name, minus_b=True)
        bool_annotation = my_bool(annotation)
        bool_status = my_bool(status)
        if (bool_annotation or bool_status) and not branch_name:
            branch_name = M.menu()

        # add annnotation and status
        if bool_annotation:
            if annotation == True:
                annotation = prompt('annotation> ')
            annotate(branch_name, annotation)
        if bool_status:
            if status == True:
                status = prompt('status> ')
            add_status(branch_name, status)
    return fn

def go_to_prev_branch(t, tokens):
    try:
        f = open(M.history_path, mode='r')
    except FileNotFoundError:
        history_is_empty()
    else:
        name = list(f)[-1][:-1]
        f.close()
        change_branch(name)

def go_to_branch_by_history(t, tokens):
    change_branch(M.menu(history()))

def delete_branch(t, tokens):
    common_delete_branch(t, tokens, '-d')

def force_delete_branch(t, tokens):
    common_delete_branch(t, tokens, '-D')

def print_augmented_branches(t, tokens):
    print_str_list(M.ini().augment())

def print_augmented_history(t, tokens):
    print_str_list(M.ini().augment(history()))

def print_raw_branch_list(t, tokens):
    print_str_list(branches())

def print_raw_history(t, tokens):
    print_str_list(history())

# TODO: make a separate manpage. this will enable git-help command
def print_help(t, tokens):
    print('''NAME
      git-b — Interaction with git branches for the most common tasks

SYNOPSIS
      git-b [ <single entry statement> | <composite statement> ]

STATEMENTS
  <single entry statement>
      -
          Go to previous branch in history.
          Git: git checkout *previous branch*

      BRANCH
          Go to BRANCH. BRANCH is a BRANCH_NAME or BRANCH_ID.
          Git: git checkout BRANCH

      -d|--delete BRANCH*
          Delete one or more branches.
          Git: git branch -d BRANCH # maybe several times

      -D|--force-delete BRANCH*
          Force delete one or more branches.
          Git: git branch -D BRANCH # maybe several times

      -n|--new-branch BRANCH_NAME?
          Create new branch and go to it.
          Git: git checkout -b BRANCH_NAME'

      -a|--annotate STR*
          Add an annotation to a branch you'd choose from a menu.

      -s|--status STR*
          Add a status to a branch you'd choose from a menu.

      -l|--list
          Print branch list augmented with metadata.

      -li|-lh|--list-history
          Print history list augmented with metadata.

      -rl|--raw-list
          Print raw branch list.
          Git: git for-each-ref --format="%(refname:short)" refs/heads/

      -rh|--raw-history
          Print raw history list.

      -h|--help|-u|--usage
          Print this help message.

  <composite statement>

''')

## MAIN

def execute_command(args):
    tokens = lex(args)
    type2fn = {
        T.STR: composite_command('branch', lambda _: (t.lexem, None)),
        T.ID: composite_command('branch', lambda _: (branch_by_id_tok(t), None)),
        T.PREV: go_to_prev_branch,
        T.HISTORY: go_to_branch_by_history,
        T.BRANCH: composite_command('branch', take_next_branch),
        T.NEW: composite_command('new-branch', take_next_new_branch),
        T.ANNOTATE: composite_command('annotation', take_upto_non_str),
        T.STATUS: composite_command('status', take_upto_non_str),
        T.DELETE: delete_branch,
        T.FORCE_DELETE: force_delete_branch,
        T.LIST: print_augmented_branches,
        T.LIST_HISTORY: print_augmented_history,
        T.RAW_LIST: print_raw_branch_list,
        T.RAW_LIST_HISTORY: print_raw_history,
        T.HELP: print_help
    }
    try:
        t = next(tokens)
        command_fn = type2fn[t.type]
    except KeyError:
        bad_argument(t)
    else:
        command_fn(t, tokens)

def git_b(args):
    if not args:
        change_branch(M.menu())
        exit(0)
    execute_command(args)
    M.rewrite()

if __name__ == '__main__':
    git_b(argv[1:])
