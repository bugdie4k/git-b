#!/usr/bin/env python3

from sys import argv
from enum import Enum, unique
from subprocess import run, PIPE
import csv

def error(msg, code=1):
    print('git-b: ' + msg)
    exit(code)

def bad_argument(tok):
    error('Bad argument: ' + tok['lexem'])

def history_is_empty():
    error('The history is empty')

def rem_end_nl(s):
    return s[:-1] if s[-1:] == '\n' else s

def cmd(*cmd_list):
    res = run(cmd_list, stdout=PIPE)
    if res.returncode != 0:
        error("The command '" + ' '.join(cmd_list) + "' exited with code " + str(res.returncode))
        exit(res.returncode)
    retstr = res.stdout.decode('utf-8')
    return rem_end_nl(retstr)

history_upper_limit = 30
history_lower_limit = 10
dot_git = cmd('git', 'rev-parse', '--show-toplevel') + '/.git'
history_path = dot_git + '/git-b-history'
augmentations_path = dot_git + '/git-b-augmentations'

# parser

@unique
class Token(Enum):
    ID = 1
    STR = 2
    # options
    PREV = 3
    HISTORY = 4
    BRANCH = 5
    NEW = 6
    ANNOTATE = 7
    STATUS = 8
    DELETE = 9
    FORCE_DELETE = 10
    LIST = 11
    LIST_HISTORY = 12
    RAW_LIST = 13
    RAW_LIST_HISTORY = 14
    HELP = 15

def option_token(arg):
    opt2tok = {('-'): Token.PREV,
               ('-i', '--history'): Token.HISTORY,
               ('-b', '--branch'): Token.BRANCH,
               ('-n', '--new'): Token.NEW,
               ('-a', '--annotate'): Token.ANNOTATE,
               ('-s', '--status'): Token.STATUS,
               ('-d', '--delete'): Token.DELETE,
               ('-D', '--force-delete'): Token.FORCE_DELETE,
               ('-l', '--list'): Token.LIST,
               ('-lh', '--list-history'): Token.LIST_HISTORY,
               ('-rl', '--raw-list'): Token.RAW_LIST,
               ('-rh', '--raw-history'): Token.RAW_LIST_HISTORY,
               ('-h', '--help'): Token.HELP}
    for names, tok in opt2tok.items():
        if arg in names:
            return tok
    error('Bad option: ' + arg)

def token(arg):
    if arg:
        if arg[0] == '-':
            return option_token(arg)
        if arg[0] == ':':
            return Token.ID
    # it may as well be an empty string
    return Token.STR

def parse(args):
    return map(lambda arg: {'type': token(arg), 'lexem': arg}, args)

# implementation

def branches():    
    retstr = cmd('git', 'for-each-ref', '--format="%(refname:short)"', 'refs/heads/')
    return list(map(lambda ln: ln.strip('"'), retstr.split('\n')))

def read_metadata():
    try:
        f = open(augmentations_path, mode='r')
    except FileNotFoundError:
        return None, None
    else:
        reader = csv.DictReader(f, ['recency', 'branch', 'id', 'annotation', 'status'])
        metadata = {}
        maxrecency = -1
        for row in reader:            
            recency = int(row['recency'])
            if recency > maxrecency:
                maxrecency = recency
            metadata[row['branch']] = {'recency': recency,
                                       'id': row['id'],
                                       'annotation': row['annotation'],
                                       'status': row['status']}
        f.close()
        return metadata, maxrecency

def cmp_to_key(cmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return cmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return cmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return cmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return cmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return cmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return cmp(self.obj, other.obj) != 0
    return K

def cmp_branch_datas(this, other):
    this_recency = int(this['recency'])
    other_recency = int(other['recency'])
    if this_recency < other_recency:
        return -1
    elif this_recency > other_recency:
        return 1
    elif this_recency == other_recency:
        this_id = int(this['id'])
        other_id = int(other['id'])
        if this_id < other_id:
            return -1
        elif this_id > other_id:
            return 1
        elif this_id > other_id:
            raise RuntimeError('Found two identical ids on branch {} and branch {}'
                               .format(this['branch'], other['branch']))

def sort_by_recency(data):
    data_list = map(lambda kv: dict(kv[1], branch=kv[0]), data.items())
    return sorted(data_list, key=cmp_to_key(cmp_branch_datas))

def rewrite(data):
    with open(augmentations_path, mode='w') as f:
        writer = csv.writer(f)
        for b, b_data in data.items():
            writer.writerow([b_data['recency'], b, b_data['id'], b_data['annotation'], b_data['status']])
    return data

def fix_difference(difference, data, maxrecency):
    newrecency = maxrecency + 1
    for branch in difference:
        if branch in data.keys():
            data.pop(branch, None)
        else:
            data[branch] = {'recency': newrecency,
                            'id': unique_id(map(lambda key: data[key]['id'], data)),
                            'annotation': '',
                            'status': ''}
    return rewrite(data), newrecency if newrecency is not None else maxrecency

def branch_metadata(branch_list):
    data, maxrecency = read_metadata()
    if (data, maxrecency) == (None, None):
        return rewrite(init_data(branch_list)), 0
    difference = set(branch_list) ^ set(data.keys())
    if difference:
        return fix_difference(difference, data, maxrecency)
    return data, maxrecency

def augmented_row_str(branch_data, this_branch):
    id = branch_data['id']
    branch = branch_data['branch']
    annotation = branch_data['annotation']
    status = branch_data['status']
    status = '[' + status + ']' if status else ''
    if not annotation and not status:
        row = ' {:<3} {}'.format(id, branch)
    else:
        row = ' {:<3} {:<20} {:<3} {} {}'.format(id, branch, id, status, annotation)
    if branch == this_branch:
        return '*' + row
    else:
        return ' ' + row

def init_data(branch_list):
    data = {}
    for i, branch in enumerate(branch_list):
        data[branch] = {'recency': 0,
                        'id': str(i),
                        'annotation': '',
                        'status': ''}
    return data

def str_integers():
    i = -1
    while True:
        i += 1
        yield str(i)

def unique_id(ids):
    ids_set = set(ids)
    for id in str_integers():
        if not id in ids_set:
            return id

def augment(branch_list):
    data, maxrecency = branch_metadata(branch_list)
    this_branch = cur_branch()
    augmented_list = []
    for data_obj in sort_by_recency(data):
        augmented_list.append(augmented_row_str(data_obj, this_branch))
    return augmented_list, data

def kb_interrupt():
    print()
    exit(0)

def make_id_a_key(data):
    data_by_id = {}
    for branch in data:
        data_by_id[data[branch]['id']] = {'branch': branch,
                                          'annotation': data[branch]['annotation'],
                                          'status': data[branch]['status']}
    return data_by_id

def menu(augmented_list_and_data):
    augmented_list, data = augmented_list_and_data    
    for line in augmented_list:
        print(line)
    try:
        id = input('> ')
    except KeyboardInterrupt:
        kb_interrupt()
    return make_id_a_key(data)[id]['branch']

def history():
    try:
        f = open(history_path, mode='r')
    except FileNotFoundError:
        history_is_empty()
    else:
        history_list = list(map(lambda ln: rem_end_nl(ln), f))
        f.close()
        return history_list

def cur_branch():
    return cmd('git', 'rev-parse', '--abbrev-ref', 'HEAD')

def cut_history(history_file):
    lines = list(history_file)
    if len(lines) > history_upper_limit:
        history_file.truncate()
        history_file.writelines(lines[-history_lower_limit:])
    return history_file

def change_branch(name, minus_b=False):
    original_branch = cur_branch()
    if minus_b:
        cmd('git', 'checkout', '-b', name)
    else:
        cmd('git', 'checkout', name)
    with open(history_path, mode='a+') as f:
        cut_history(f).write(original_branch + '\n')

def print_str_list(lst):
    print('\n'.join(lst))

def delete_branch_by_name(name, option='-d'):
    delete_report = cmd('git', 'branch', option, name)
    print(delete_report)

def to_id(tok):
    return tok['lexem'][1:]

def branch_from_id(tok):
    data, _ = branch_metadata(branches())
    return make_id_a_key(data)[to_id(tok)]['branch']

def common_delete_branch(t, tokens, option='-d'):
    # TODO: deleting several branches
    try:
        t = next(tokens)
    except StopIteration:
        delete_branch_by_name(menu(augment(branches())), option)
    else:
        if t['type'] == Token.STR:
            delete_branch_by_name(t['lexem'], option)
        elif t['type'] == Token.ID:
            delete_branch_by_name(branch_from_id(t), option)
        else:
            bad_argument(t)

# commands

def go_to_branch_by_name(t, tokens):
    change_branch(t['lexem'])

def go_to_branch_by_id(t, tokens):
    change_branch(branch_from_id(t))

def go_to_prev_branch(t, tokens):
    try:
        f = open(history_path, mode='r')
    except FileNotFoundError:
        history_is_empty()
    else:
        name = list(f)[-1][:-1]
        f.close()
        change_branch(name)

def go_to_branch_by_history(t, tokens):
    change_branch(menu(augment(history())))

def new_branch(t, tokens):
    # TODO: add -n B -a A syntax
    try:
        t = next(tokens)
    except StopIteration:
        try:
            name = input('branch name> ')
        except KeyboardInterrupt:
            kb_interrupt()
        else:
            change_branch(name, minus_b=True)
    else:
        if t['type'] != Token.STR:
            error('Bad branch name: ' + t['lexem'])
        change_branch(t['lexem'], minus_b=True)

def make_an_annotation(name, annotation):
    data, _ = branch_metadata(branches())
    data[name]['annotation'] = annotation
    rewrite(data)
    exit(0)

def annotate(t, tokens):
    # TODO: figure out a way to make it better
    # maybe collect all the stuff beforehand
    # maybe abandon these not so useful cool syntax
    annotation = []
    try:
        t = next(tokens)
    except StopIteration:
        make_an_annotation(menu(augment(branches())), input('annotation> '))
    else:        
        annotation.append(t['lexem'])
        while True:
            try:
                t = next(tokens)
            except StopIteration:
                make_an_annotation(menu(augment(branches())), ' '.join(annotation))
            else:
                if t['type'] != Token.STR:
                    break
                else:
                    annotation.append(t['lexem'])
        if t['type'] == Token.BRANCH:
            try:
                t = next(tokens)
            except StopIteration:
                error('Expected a branch name or id after ' + t['lexem'] + ' option')
            else:
                if t['type'] == Token.STR:
                    make_an_annotation(t['lexem'], ' '.join(annotation))
                elif t['type'] == Token.ID:
                    make_an_annotation(branch_from_id(t['lexem']),' '.join(annotation))
                else:
                    bad_argument(t)

def status(t, tokens):
    pass

def delete_branch(t, tokens):
    common_delete_branch(t, tokens, '-d')

def force_delete_branch(t, tokens):
    common_delete_branch(t, tokens, '-D')

def print_augmented_branches(t, tokens):
    print_str_list(augment(branches())[0])

def print_augmented_history(t, tokens):
    print_str_list(augment(history())[0])

def print_raw_branch_list(t, tokens):
    print_str_list(branches())

def print_raw_history(t, tokens):
    print_str_list(history())

def print_help(t, tokens):
    print('IM HELPIN U')

def git_b(args):
    if not args:
        change_branch(menu(augment(branches())))
        exit(0)

    tokens = parse(args)
    type2fn = {
        Token.STR: go_to_branch_by_name,
        Token.ID: go_to_branch_by_id,
        Token.PREV: go_to_prev_branch,
        Token.HISTORY: go_to_branch_by_history,
        Token.BRANCH: lambda: error('not implemented'),
        Token.NEW: new_branch,
        Token.ANNOTATE: annotate,
        Token.STATUS: status,
        Token.DELETE: delete_branch,
        Token.FORCE_DELETE: force_delete_branch,
        Token.LIST: print_augmented_branches,
        Token.LIST_HISTORY: print_augmented_history,
        Token.RAW_LIST: print_raw_branch_list,
        Token.RAW_LIST_HISTORY: print_raw_history,
        Token.HELP: print_help
    }
    try:
        t = next(tokens)
        command_fn = type2fn[t['type']]
    except KeyError:
        bad_argument(t)
    else:
        command_fn(t, tokens)

if __name__ == '__main__':
    git_b(argv[1:])
