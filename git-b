#!/usr/bin/env python3

from sys import argv
from enum import Enum, unique
from subprocess import run, PIPE
import csv

def error(msg, code=1):
    print('git-b: ' + msg)
    exit(code)

def rem_end_nl(s):
    return s[:-1] if s[-1:] == '\n' else s

def cmd(*cmd_list):
    res = run(cmd_list, stdout=PIPE)
    if res.returncode != 0:
        error("\n  The command:\n      " \
              + ' '.join(cmd_list) \
              + "\n  exited with code:\n      " \
              + str(res.returncode))
        exit(res.returncode)
    retstr = res.stdout.decode('utf-8')
    return rem_end_nl(retstr)

# globals

dot_git = cmd('git', 'rev-parse', '--show-toplevel') + '/.git'

history_len = 40
history_path = dot_git + '/git-b-history'

# lexer

def integers(start=0):
    i = start - 1
    while True:
        i += 1
        yield i

#TODO: rename Token to T
@unique
class Token(Enum):
    __genint = integers(1)
    #
    ID = next(__genint)
    STR = next(__genint)
    # options
    PREV = next(__genint)
    HISTORY = next(__genint)
    BRANCH = next(__genint)
    NEW = next(__genint)
    ANNOTATE = next(__genint)
    STATUS = next(__genint)
    DELETE = next(__genint)
    FORCE_DELETE = next(__genint)
    LIST = next(__genint)
    LIST_HISTORY = next(__genint)
    RAW_LIST = next(__genint)
    RAW_LIST_HISTORY = next(__genint)
    HELP = next(__genint)
    #
    SHOW_DELETED = next(__genint) # TODO: implement
    UPDATE_IDS = next(__genint)

def option_token(arg):
    opt2tok = {('-'): Token.PREV,
               ('-i', '--history'): Token.HISTORY,
               ('-b', '--branch'): Token.BRANCH,
               ('-n', '--new'): Token.NEW,
               ('-a', '--annotate'): Token.ANNOTATE,
               ('-s', '--status'): Token.STATUS,
               ('-d', '--delete'): Token.DELETE,
               ('-D', '--force-delete'): Token.FORCE_DELETE,
               ('-l', '--list'): Token.LIST,
               ('-lh', '-li', '--list-history'): Token.LIST_HISTORY,
               ('-rl', '--raw-list'): Token.RAW_LIST,
               ('-rh', '--raw-history'): Token.RAW_LIST_HISTORY,
               ('-h', '-u', '--usage'): Token.HELP}
    for names, tok in opt2tok.items():
        if arg in names:
            return tok
    error('Bad option: ' + arg)

def token(arg):
    if arg:
        if arg[0] == '-':
            return option_token(arg)
        if arg[0] == ':':
            return Token.ID
    # it may as well be an empty string
    return Token.STR

def lex(args):
    return map(lambda arg: {'type': token(arg), 'lexem': arg}, args)

# implementation

def branches():
    retstr = cmd('git', 'for-each-ref', '--format="%(refname:short)"', 'refs/heads/')
    return list(map(lambda ln: ln.strip('"'), retstr.split('\n')))

class Branch:
    def __init__(self, dictionary):
        self.__dict__.update(dictionary)

    def cmp(self, other):
        self_recency = int(self.recency)
        other_recency = int(other.recency)
        if self_recency < other_recency:
            return -1
        elif self_recency > other_recency:
            return 1
        else:
            self_id = int(self.id)
            other_id = int(other.id)
            if self_id < other_id:
                return -1
            elif self_id > other_id:
                return 1
            else:
                raise RuntimeError(
                    'Found two identical ids on branch {} and branch {}'
                    .format(self.branch, other.branch))

    def __lt__(self, other): return self.cmp(other) < 0
    def __gt__(self, other): return self.cmp(other) > 0
    def __eq__(self, other): return self.cmp(other) == 0
    def __le__(self, other): return self.cmp(other) <= 0
    def __ge__(self, other): return self.cmp(other) >= 0
    def __ne__(self, other): return self.cmp(other) != 0

def str_integers():
    for i in integers():
        yield str(i)

def unique_id(ids):
    for id in str_integers():
        if not id in ids:
            return id

def augmented_branch_str(branch_data, this_branch):
    id = branch_data.id
    branch = branch_data.branch
    annotation = branch_data.annotation
    status = branch_data.status
    status = '[' + status + ']' if status else ''
    if not annotation and not status:
        row = ' {:<3} {}'.format(id, branch)
    else:
        row = ' {:<3} {:<20} {:<3} {} {}'.format(id, branch, id, status, annotation)
    if branch == this_branch:
        return '*' + row
    else:
        return ' ' + row

#TODO: make Metadata global and singleton
class Metadata:
    path = dot_git + '/git-b-metadata'
    csv_fields_order = ['branch', 'id', 'recency', 'annotation', 'status']

    def __init__(self):
        self._initialized = False
        self.branch_list = branches()
        self.data = []
        self.branch2data = {}
        self._id2data = {}
        self.maxrecency = -1

    @property
    def id2data(self):
        if self._id2data:
            return self._id2data
        else:
            self._id2data = dict(zip(map(lambda b: b.id, self.data),
                                     self.data))
            return self._id2data

    def ini(self):
        "Initialize fields and fix possible differences"
        if self._initialized:
            return self
        try:
            f = open(Metadata.path, mode='r')
        except FileNotFoundError:
            self.create_metadata().rewrite()
        else:
            self.read_metadata(f)
            f.close()
        branches_from_data = set(self.branch2data.keys())
        difference = set(self.branch_list) ^ branches_from_data
        if difference:
            self.fix_difference(difference, branches_from_data)
        self._initialized = True
        return self

    def create_metadata(self):
        self.maxrecency = 0
        common = {'recency': 0, 'annotation': '', 'status': ''}
        for index, branch in enumerate(self.branch_list):
            b_data = Branch(dict(common, id=str(index), branch=branch))
            self.data.append(b_data)
            self.branch2data[branch] = b_data
        return self

    def read_metadata(self, file):
        reader = csv.DictReader(file, Metadata.csv_fields_order)
        for row in reader:
            recency = int(row['recency'])
            if recency > self.maxrecency:
                self.maxrecency = recency
            row['recency'] = recency
            b_data = Branch(row)
            self.data.append(b_data)
            self.branch2data[b_data.branch] = b_data

    def rewrite(self):
        # TODO: think about delaying rewrite up to the end
        with open(Metadata.path, mode='w') as f:
            writer = csv.DictWriter(f, Metadata.csv_fields_order)
            for b_data in self.data:
                writer.writerow(b_data.__dict__)

    def fix_difference(self, difference, branches_from_data):
        newrecency = self.maxrecency + 1
        to_delete = []
        to_add = []
        for branch in difference:
            if branch in branches_from_data:
                to_delete.append(branch)
            else:
                to_add.append(branch)
        if to_delete:
            for branch in to_delete:
                b_data = self.branch2data[branch]
                self.branch2data.pop(b_data.branch, None)
                del self.data[self.data.index(b_data)]
        if to_add:
            common = {'recency': newrecency, 'annotation': '', 'status': ''}
            ids_set = set(map(lambda d: d.id, self.data))
            for branch in to_add:
                newid = unique_id(ids_set)
                ids_set.add(newid)
                b_data = Branch(dict(common, id=newid, branch=branch))
                self.data.append(b_data)
                self.branch2data[branch] = b_data
        self.rewrite()

    def augment(self, branches_to_augment=None):
        if branches_to_augment is None:
            branches = map(lambda d: d.branch, sorted(self.data))
        else:
            branches = branches_to_augment
        this_branch = cur_branch()
        augmented_list = []
        for branch in branches:
            try:
                b_data = self.branch2data[branch]
            except KeyError:
                augmented_list.append('  {:<3} {}'.format('-', branch))
            else:
                augmented_list.append(
                    augmented_branch_str(
                        b_data, this_branch))
        return augmented_list

    def menu(self, branches_to_augment=None):
        self.ini()
        print_str_list(self.augment(branches_to_augment))
        try:
            id = prompt('> ')
            return self.id2data[id].branch
        except KeyError:
            error('Bad id: ' + id)

def kb_interrupt():
    print()
    exit(0)

def prompt(prompt_msg):
    try:
        return input(prompt_msg)
    except KeyboardInterrupt:
        print()
        exit(0)

def make_id_a_key(data):
    data_by_id = {}
    for branch in data:
        data_by_id[data[branch]['id']] = {'branch': branch,
                                          'annotation': data[branch]['annotation'],
                                          'status': data[branch]['status']}
    return data_by_id

def history_is_empty():
    error('The history is empty')

def history():
    # TODO:
    # * store exit time in history
    # * store HEAD's hash when exited
    # * hide nonexistent branches from history
    # * * option to show these branches
    try:
        f = open(history_path, mode='r')
    except FileNotFoundError:
        history_is_empty()
    else:
        history_list = list(map(lambda ln: rem_end_nl(ln), f))
        f.close()
        return history_list

def cur_branch():
    return cmd('git', 'rev-parse', '--abbrev-ref', 'HEAD')

def cut_history():
    with open(history_path, mode='r+') as f:
        lines = list(f)
        if len(lines) > history_len:
            f.truncate(0)
            f.writelines(lines[-history_len:])

def change_branch(name, minus_b=False):
    original_branch = cur_branch()
    if minus_b:
        cmd('git', 'checkout', '-b', name)
    else:
        cmd('git', 'checkout', name)
    with open(history_path, mode='a') as f:
        f.write(original_branch + '\n')
    cut_history()

def print_str_list(lst):
    print('\n'.join(lst))

def delete_branch_by_name(name, option='-d'):
    delete_report = cmd('git', 'branch', option, name)
    print(delete_report)

def to_id(tok):
    return tok['lexem'][1:]

def branch_by_id_tok(tok):
    return Metadata().ini().id2data[to_id(tok)].branch

def bad_argument(tok):
    error('Bad argument: ' + tok['lexem'])

def common_delete_branch(t, tokens, option='-d'):
    deletions = []
    def take1():
        try:
            t = next(tokens)
        except StopIteration:
            return False
        else:
            if t['type'] == Token.STR:
                del_fn = lambda: delete_branch_by_name(t['lexem'], option)
            elif t['type'] == Token.ID:
                del_fn = lambda: delete_branch_by_name(branch_by_id_tok(t), option)
            else:
                bad_argument(t)
            deletions.append(del_fn)
            return True
    if not take1():
        delete_branch_by_name(Metadata().menu(), option)
    else:
        while take1():
            pass
        for del_fn in deletions:
            del_fn()
        Metadata().ini() # update metadata

def take_next_branch(tokens):
    try:
        t = next(tokens)
    except StopIteration:
        return True, None
    else:
        if t['type'] == Token.STR:
            return t['lexem'], None
        elif t['type'] == Token.ID:
            return branch_by_id_tok(t), None
        else:
            return True, t

def take_next_new_branch(tokens):
    try:
        t = next(tokens)
    except StopIteration:
        return True, None
    else:
        if t['type'] == Token.STR:
            return t['lexem'], None
        else:
            return None, t

def take_upto_non_str(tokens):
    annotation = []
    getres = lambda: ' '.join(annotation) if annotation else True
    while True:
        try:
            t = next(tokens)
        except StopIteration:
            return getres(), None
        else:
            if t['type'] == Token.STR or t['type'] == Token.ID:
                annotation.append(t['lexem'])
            else:
                return getres(), t

def parse_composite_command(t, tokens, info):
    typemap = {
        Token.BRANCH: ('branch', take_next_branch),
        Token.NEW: ('new-branch', take_next_new_branch),
        Token.ANNOTATE: ('annotations', take_upto_non_str),
        Token.STATUS: ('status', take_upto_non_str)
    }
    next_t = t
    while True:
        if next_t:
            t = next_t
            next_t = None
        else:
            try:
                t = next(tokens)
            except StopIteration:
                return info
        field, fn = typemap[t['type']]
        value, next_t = fn(tokens)
        info[field] = value

def get_field(dict, field):
    try:
        return dict[field]
    except KeyError:
        return None

def my_bool(arg):
    if arg == '':
        return True
    return bool(arg)

# commands

def annotate(metadata, branch, annotation):
    metadata.ini()
    metadata.branch2data[branch].annotation = annotation
    metadata.rewrite()

def add_status(metadata, branch, status):
    metadata.ini()
    metadata.branch2data[branch].status = status
    metadata.rewrite()

# TODO: clean up
def composite_command(field, take_field):
    def fn(_, tokens):
        value, next_t = take_field(tokens)
        info = parse_composite_command(next_t, tokens, { field: value })
        branch = get_field(info, 'branch')
        new_branch = get_field(info, 'new-branch')
        annotation = get_field(info, 'annotation')
        status = get_field(info, 'status')
        boolify = lambda *args: tuple( my_bool(arg) for arg in args )
        m = Metadata()
        branch_name = None
        if boolify(branch, new_branch) == (True, True):
            error('Mutually exclusive arguments: --branch and --new-branch')
        elif boolify(branch, annotation, status) == (True, False, False):
            go_to_branch_by_name(branch)
        elif branch:
            if branch == True:
                branch_name = m.menu()
            else:
                branch_name = branch
        elif new_branch:
            if new_branch == True:
                branch_name = m.menu()
            else:
                branch_name = new_branch
            change_branch(branch_name, minus_b=True)
        if not branch_name and (my_bool(annotation) or my_bool(status)):
            branch_name = m.menu()
        if my_bool(annotation):
            if annotation == True:
                annotation = input('annotation> ')
            annotate(m, branch_name, annotation)
        if my_bool(status):
            if status == True:
                status = input('status> ')
            add_status(m, branch_name, status)
    return fn

def go_to_branch_by_name(t, tokens):
    change_branch(t['lexem'])

def go_to_prev_branch(t, tokens):
    try:
        f = open(history_path, mode='r')
    except FileNotFoundError:
        history_is_empty()
    else:
        name = list(f)[-1][:-1]
        f.close()
        change_branch(name)

def go_to_branch_by_history(t, tokens):
    change_branch(Metadata().menu(history()))

def delete_branch(t, tokens):
    common_delete_branch(t, tokens, '-d')

def force_delete_branch(t, tokens):
    common_delete_branch(t, tokens, '-D')

def print_augmented_branches(t, tokens):
    print_str_list(Metadata().ini().augment())

def print_augmented_history(t, tokens):
    print_str_list(Metadata().ini().augment(history()))

def print_raw_branch_list(t, tokens):
    print_str_list(branches())

def print_raw_history(t, tokens):
    print_str_list(history())

def print_help(t, tokens):
    print('IM HELPIN U')

def git_b(args):
    if not args:
        change_branch(Metadata().menu())
        exit(0)

    tokens = lex(args)
    type2fn = {
        Token.STR: composite_command('branch', lambda _: (t['lexem'], None)), # go_to_branch_by_name,
        Token.ID: composite_command('branch', lambda _: (branch_by_id_tok(t), None)), # go_to_branch_by_id,
        Token.PREV: go_to_prev_branch,
        Token.HISTORY: go_to_branch_by_history,
        Token.BRANCH: composite_command('branch', take_next_branch), # lambda: error('not implemented'),
        Token.NEW: composite_command('new-branch', take_next_new_branch), # new_branch,
        Token.ANNOTATE: composite_command('annotation', take_upto_non_str), # annotate,
        Token.STATUS: composite_command('status', take_upto_non_str), # status,
        Token.DELETE: delete_branch,
        Token.FORCE_DELETE: force_delete_branch,
        Token.LIST: print_augmented_branches,
        Token.LIST_HISTORY: print_augmented_history,
        Token.RAW_LIST: print_raw_branch_list,
        Token.RAW_LIST_HISTORY: print_raw_history,
        Token.HELP: print_help
    }
    try:
        t = next(tokens)
        command_fn = type2fn[t['type']]
    except KeyError:
        bad_argument(t)
    else:
        command_fn(t, tokens)

if __name__ == '__main__':
    git_b(argv[1:])
